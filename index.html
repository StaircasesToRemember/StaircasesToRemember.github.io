<!DOCTYPE html>
<html>
<body>

<canvas id="arena" width="400" height="1000" style="border:0px solid black;"></canvas>

<script>
const canvas = document.getElementById("arena");
const cardCosts = [3, 4, 2, 5]; // cost for each of the 4 cards
const units = [];
const bridges = [
  { x: 75, y: 600 / 2 },  // middle of first bridge
  { x: 325, y: 600 / 2 }  // middle of second bridge
];
const PlacementType = {
  PLAYER_SIDE_ONLY: "player",
  ANYWHERE: "anywhere"
};

const cards = [
  { name: "Knight", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY },
  { name: "Musketeer", cost: 4, placement: PlacementType.ANYWHERE },
  { name: "Giant", cost: 5, placement: PlacementType.PLAYER_SIDE_ONLY },
  { name: "Archers", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY }
];
const card = cards[selectedCardIndex];
const cost = card.cost;

// Player elixir values
let playerElixir = 6;
let enemyElixir = 6;
const maxElixir = 10;

// Card selected variables
let selectedCardIndex = null; // 0â€“3, or null if none selected
const handCards = [];
const ARENA_HEIGHT = 600;

const ATTACK_RANGE = 20;
const ATTACK_DAMAGE = 10;
const ATTACK_COOLDOWN = 60; // frames (~1 second at 60fps)
  
function spawnUnit(x, y, team) {
  units.push({
    x: x,
    y: y,
    r: 10,
    team: team,
    hp: 100
  });
}

function canPlaceCard(card, x, y, team) {
  // River
  if (y >= 275 && y <= 325) return false;

  if (card.placement === PlacementType.PLAYER_SIDE_ONLY) {
    if (team === "player" && y < 325) return false;
    if (team === "enemy" && y > 275) return false;
  }

  return true;
}
  
function drawUnits() {
  for (const u of units) {
    u.draw(ctx);
  }
}

function getEnemyUnits(unit) {
  return units.filter(u => u.team !== unit.team);
}

  
// Draw elixir bar
function drawElixirBar() {
  const barWidth = 200;
  const barHeight = 20;
  const x = 100;
  const y = 650;

  // ðŸ”´ CLEAR the elixir bar area first
  ctx.clearRect(x - 5, y - 5, barWidth + 120, barHeight + 20);

  // Background
  ctx.fillStyle = "lightgray";
  ctx.fillRect(x, y, barWidth, barHeight);

  // Elixir fill
  ctx.fillStyle = "magenta";
  const fillWidth = (playerElixir / maxElixir) * barWidth;
  ctx.fillRect(x, y, fillWidth, barHeight);

  // Text
  ctx.fillStyle = "magenta";
  ctx.font = "16px Arial";
  ctx.fillText(
    playerElixir + " / " + maxElixir,
    x + barWidth + 10,
    y + barHeight - 4
  );
}

function distance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
  
// Draw hand
function drawHand() {
  const cardWidth = 70;
  const cardHeight = 100;
  const startX = 25;
  const y = 725;
  const spacing = 24;

  for (let i = 0; i < 4; i++) {
    const x = startX + i * (cardWidth + spacing);

    // store card bounds
    handCards.push({ x, y, w: cardWidth, h: cardHeight });

    // highlight if selected
    if (selectedCardIndex === i) {
      ctx.fillStyle = "gold";
      ctx.fillRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8);
    }

    // card body
    const cost = cardCosts[i];

    if (playerElixir < cost) {
      ctx.globalAlpha = 0.5;
    }

    ctx.fillStyle = "white";
    ctx.fillRect(x, y, cardWidth, cardHeight);
    ctx.globalAlpha = 1.0;


    // border
    ctx.strokeStyle = "black";
    ctx.strokeRect(x, y, cardWidth, cardHeight);
  }
}
  
  
// Tower class
class Tower {
  constructor(x, y, hp, team) {
    this.x = x;
    this.y = y;
    this.hp = hp;
    this.maxHp = hp;
    this.team = team;
  }

  draw(ctx) {
    ctx.fillStyle = this.team === "player" ? "lightskyblue" : "lightpink";
    ctx.fillRect(this.x - 25, this.y - 25, 50, 50);
    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(this.x - 25, this.y - 35, 50 * (this.hp / this.maxHp), 5);
  }
}

// Create towers
const playerTowers = [
  new Tower(75, 500, 1000, "player"),
  new Tower(200, 550, 2000, "player"),
  new Tower(325, 500, 1000, "player")
];

const enemyTowers = [
  new Tower(75, 100, 1000, "enemy"),
  new Tower(200, 50, 2000, "enemy"),
  new Tower(325, 100, 1000, "enemy")
];

class Unit {
  constructor(x, y, team) {
    this.x = x;
    this.y = y;
    this.team = team;
    this.hp = 100;
    this.r = 24;
    this.type = "knight";

    this.speed = 1.0;
    this.sightRange = 150;
    this.target = null;
    this.attacking = false;
    this.attackCooldown = 0;
  }

  draw(ctx) {
    // Draw Knight
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fillStyle = this.team === "player" ? "yellow" : "yellow";
    ctx.fill();
    ctx.closePath();

    // Draw HP bar
    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(this.x - this.r, this.y - this.r - 6, (this.hp / 100) * this.r * 2, 4);
    ctx.strokeStyle = "black";
    ctx.strokeRect(this.x - this.r, this.y - this.r - 6, this.r * 2, 4);
  }

update() {
  // Reduce cooldown
  if (this.attackCooldown > 0) {
    this.attackCooldown--;
  }

  // Determine enemies
  const enemyUnits = units.filter(u => u.team !== this.team);
  const enemyTowersList = this.team === "player" ? enemyTowers : playerTowers;

  // Remove dead target
  if (this.target && this.target.hp <= 0) {
    this.target = null;
  }

  // Acquire target if none
  if (!this.target) {
    let closest = null;
    let closestDist = Infinity;

    // Check enemy units
    for (const u of enemyUnits) {
      const d = distance(this, u);
      if (d < closestDist && d <= this.sightRange) {
        closest = u;
        closestDist = d;
      }
    }

    // If no unit target, check towers
    if (!closest) {
      for (const t of enemyTowersList) {
        const d = distance(this, t);
        if (d < closestDist) {
          closest = t;
          closestDist = d;
        }
      }
    }

    this.target = closest;
  }

  if (!this.target) return;

  const d = distance(this, this.target);

  // Attack
  if (d <= ATTACK_RANGE) {
    if (this.attackCooldown === 0) {
      this.target.hp -= ATTACK_DAMAGE;
      this.attackCooldown = ATTACK_COOLDOWN;
    }
    return;
  }

  // Move toward target
  const dx = this.target.x - this.x;
  const dy = this.target.y - this.y;
  const mag = Math.hypot(dx, dy);

  if (mag > 0) {
    this.x += (dx / mag) * this.speed;
    this.y += (dy / mag) * this.speed;
  }
}



  closestBridge() {
    let best = null;
    let minDist = Infinity;
    for (const b of bridges) {
      const dx = b.x - this.x;
      const dy = b.y - this.y;
      const d = Math.hypot(dx, dy);
      if (d < minDist) {
        minDist = d;
        best = b;
      }
    }
    return best;
  }

  closestTower(towers) {
    let best = null;
    let minDist = Infinity;
    for (const t of towers) {
      const dx = t.x - this.x;
      const dy = t.y - this.y;
      const d = Math.hypot(dx, dy);
      if (d < minDist) {
        minDist = d;
        best = t;
      }
    }
    return best;
  }
}



// Function to generate elixir
function generateElixir() {
  if (playerElixir < maxElixir) playerElixir += 1;
  if (enemyElixir < maxElixir) enemyElixir += 1;
  
  console.log("Player Elixir:", playerElixir, "Enemy Elixir:", enemyElixir);
}

// Draw loop
  // Draw grass
function drawArena() {
  ctx.fillStyle = "lightgreen";
  ctx.fillRect(0, 0, canvas.width, 600);

  // Draw hand 
  ctx.fillStyle = "#ddd";
  ctx.fillRect(0, 700, canvas.width, 150);
  drawHand();
  
   // Draw river
  ctx.fillStyle = "#1E90FF"; // blue river
  ctx.fillRect(0, 275, canvas.width, 50);

    // Draw bridges
  ctx.fillStyle = "#8B4513"; // brown
  const bridgeWidth = 50;
  const bridgeHeight = 100;
  const bridgeXs = [75, 325];

  for (let x of bridgeXs) {
    ctx.fillRect(x - bridgeWidth/2, 275 - (bridgeHeight - 50)/2, bridgeWidth, bridgeHeight);
  }

  for (let t of playerTowers) {
    t.draw(ctx);
  }

  for (let t of enemyTowers) {
    t.draw(ctx);
  }

  //draw units
  for (let i = units.length - 1; i >= 0; i--) {
  const u = units[i];
  u.update();
  u.draw(ctx);

  if (u.hp <= 0) {
    units.splice(i, 1);
  }
}



  //draw elixir bar
  drawElixirBar();

  requestAnimationFrame(drawArena);
}

drawArena();
  
// Generate 1 elixir every 2.8 seconds
setInterval(generateElixir, 2800);

  // Event listener
 canvas.addEventListener("click", function (e) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // 1ï¸âƒ£ Check card clicks FIRST
  for (let i = 0; i < handCards.length; i++) {
    const c = handCards[i];

    if (
      mouseX >= c.x &&
      mouseX <= c.x + c.w &&
      mouseY >= c.y &&
      mouseY <= c.y + c.h
    ) {
      selectedCardIndex = i;
      console.log("Selected card:", i);
      return; // stop here
    }
  }

// 2ï¸âƒ£ Check arena click
if (selectedCardIndex !== null && mouseY <= ARENA_HEIGHT) {
  const card = cards[selectedCardIndex];

  if (!canPlaceCard(card, mouseX, mouseY, "player")) {
    console.log("Illegal placement");
    return;
  }

  
  const cost = cardCosts[selectedCardIndex];
  
  if (playerElixir < cost) {
    console.log("Not enough elixir!");
    return;
  }

  playerElixir -= cost;

  // SPAWN KNIGHT
  units.push(new Unit(mouseX, mouseY, "player"));

  console.log("Spawned Knight at", mouseX, mouseY);

  selectedCardIndex = null;
}

});

</script>

</body>
</html>
