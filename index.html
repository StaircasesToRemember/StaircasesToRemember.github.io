<!DOCTYPE html>
<html>
<body>

<canvas id="arena" width="400" height="1000" style="border:0px solid black;"></canvas>

<script>
const canvas = document.getElementById("arena");
const ctx = canvas.getContext("2d");
const cardCosts = [3, 4, 2, 5]; // cost for each of the 4 cards
const units = [];
const bridges = [
  { x: 75, y: 600 / 2 },  // middle of first bridge
  { x: 325, y: 600 / 2 }  // middle of second bridge
];
const RIVER_TOP = 275;
const RIVER_BOTTOM = 325;
const PlacementType = {
  PLAYER_SIDE_ONLY: "player",
  ANYWHERE: "anywhere"
};

const cards = [
  { name: "Knight", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY },
  { name: "Archers", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY },
  { name: "Musketeer", cost: 4, placement: PlacementType.PLAYER_SIDE_ONLY },
  { name: "Giant", cost: 5, placement: PlacementType.PLAYER_SIDE_ONLY }
];

// Player elixir values
let playerElixir = 6;
let enemyElixir = 6;
const maxElixir = 10;

// Card selected variables
let selectedCardIndex = null; // 0â€“3, or null if none selected
const handCards = [];
const ARENA_HEIGHT = 600;

const ATTACK_RANGE = 20;
const ATTACK_DAMAGE = 170;
const ATTACK_COOLDOWN = 60; // frames (~1 second at 60fps)

function sameSide(a, b) {
  // both above river
  if (a.y < RIVER_BOTTOM && b.y < RIVER_BOTTOM) return true;
  // both below river
  if (a.y > RIVER_TOP && b.y > RIVER_TOP) return true;
  return false;
}

function canPlaceCard(card, x, y, team) {
  // River
  if (y >= 275 && y <= 325) return false;

  if (card.placement === PlacementType.PLAYER_SIDE_ONLY) {
    if (team === "player" && y < 325) return false;
    if (team === "enemy" && y > 275) return false;
  }

  return true;
}
  
function drawUnits() {
  for (const u of units) {
    u.draw(ctx);
  }
}

function getEnemyUnits(unit) {
  return units.filter(u => u.team !== unit.team);
}

  
// Draw elixir bar
function drawElixirBar() {
  const barWidth = 200;
  const barHeight = 20;
  const x = 100;
  const y = 650;

  // ðŸ”´ CLEAR the elixir bar area first
  ctx.clearRect(x - 5, y - 5, barWidth + 120, barHeight + 20);

  // Background
  ctx.fillStyle = "lightgray";
  ctx.fillRect(x, y, barWidth, barHeight);

  // Elixir fill
  ctx.fillStyle = "magenta";
  const fillWidth = (playerElixir / maxElixir) * barWidth;
  ctx.fillRect(x, y, fillWidth, barHeight);

  // Text
  ctx.fillStyle = "magenta";
  ctx.font = "16px Arial";
  ctx.fillText(
    playerElixir + " / " + maxElixir,
    x + barWidth + 10,
    y + barHeight - 4
  );
}

function distance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
  
// Draw hand
function drawHand() {
  handCards.length = 0;
  const cardWidth = 70;
  const cardHeight = 100;
  const startX = 25;
  const y = 725;
  const spacing = 24;

  for (let i = 0; i < 4; i++) {
    const x = startX + i * (cardWidth + spacing);
    const card = cards[i];
    const cost = card.cost;

    // store card bounds
    handCards.push({ x, y, w: cardWidth, h: cardHeight });

    // highlight if selected
    if (selectedCardIndex === i) {
      ctx.fillStyle = "gold";
      ctx.fillRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8);
    }

    // Dim card if not enough elixir
    if (playerElixir < cost) {
      ctx.globalAlpha = 0.5;
    }

    // card body
    ctx.fillStyle = "white";
    ctx.fillRect(x, y, cardWidth, cardHeight);

    // Draw unit icon/circle in the middle
    ctx.globalAlpha = 1.0;
    ctx.beginPath();
    ctx.arc(x + cardWidth / 2, y + 35, 20, 0, Math.PI * 2);
    
    if (card.name === "Knight") ctx.fillStyle = "yellow";
    if (card.name === "Archer") ctx.fillStyle = "magenta";
    if (card.name === "Musketeer") ctx.fillStyle = "purple";
    if (card.name === "Giant") ctx.fillStyle = "orange";
    
    ctx.fill();
    ctx.closePath();

    // Draw unit name
    ctx.fillStyle = "black";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.fillText(card.name, x + cardWidth / 2, y + 70);

    // Draw elixir cost in magenta at bottom
    ctx.fillStyle = "magenta";
    ctx.font = "bold 16px Arial";
    ctx.fillText(cost, x + cardWidth / 2, y + 90);

    ctx.globalAlpha = 1.0;

    // border
    ctx.strokeStyle = "black";
    ctx.strokeRect(x, y, cardWidth, cardHeight);
  }
}
  
// In drawArena or a separate tower management function:
function updateTowers() {
  // Player towers
  for (let i = playerTowers.length - 1; i >= 0; i--) {
    const t = playerTowers[i];
    t.update();
    t.draw(ctx);

    // Optional: draw attack line
    if (t.target) {
      ctx.strokeStyle = t.team === "player" ? "blue" : "red";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(t.x, t.y);
      ctx.lineTo(t.target.x, t.target.y);
      ctx.stroke();
    }

    if (!t.isKing && t.hp <= 0) {
      playerTowers.splice(i, 1);
    }
    if (t.isKing && t.hp <= 0) {
      alert("Enemy wins!");
      location.reload(); // simple game over reset
    }
  }

  // Enemy towers
  for (let i = enemyTowers.length - 1; i >= 0; i--) {
    const t = enemyTowers[i];
    t.update();
    t.draw(ctx);

    if (t.target) {
      ctx.strokeStyle = t.team === "player" ? "blue" : "red";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(t.x, t.y);
      ctx.lineTo(t.target.x, t.target.y);
      ctx.stroke();
    }

    if (!t.isKing && t.hp <= 0) {
      enemyTowers.splice(i, 1);
    }
    if (t.isKing && t.hp <= 0) {
      alert("Player wins!");
      location.reload(); // simple game over reset
    }
  }
}

  
// Tower class
class Tower {
  constructor(x, y, hp, team, isKing = false) {
    this.x = x;
    this.y = y;
    this.hp = hp;
    this.maxHp = hp;
    this.team = team;
    this.isKing = isKing; // true if this is the king tower
    this.target = null;
  }

  draw(ctx) {
    ctx.fillStyle = this.team === "player" ? "lightskyblue" : "lightpink";
    ctx.fillRect(this.x - 25, this.y - 25, 50, 50);

    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(this.x - 25, this.y - 35, 50 * (this.hp / this.maxHp), 5);
  }

  update() {
    // King towers only attack if damaged
    if (this.isKing && this.hp === this.maxHp) return;

    // Tower attack logic here (target nearest enemy unit, deal ranged damage)
    const enemyUnits = units.filter(u => u.team !== this.team);
    if (enemyUnits.length === 0) {
      this.target = null;
      return;
    }

    // Find closest enemy
    let closest = null;
    let closestDist = Infinity;
    for (const u of enemyUnits) {
      const d = Math.hypot(u.x - this.x, u.y - this.y);
      if (d < closestDist) {
        closest = u;
        closestDist = d;
      }
    }

    if (closest && closestDist <= 175) { // attack range
      this.target = closest;
      closest.hp -= 3; // tower damage
    } else {
      this.target = null;
    }
  }
}

// Create towers
const playerTowers = [
  new Tower(75, 500, 3000, "player"),
  new Tower(200, 550, 5000, "player", true), // King tower in center
  new Tower(325, 500, 3000, "player")
];

const enemyTowers = [
  new Tower(75, 100, 3000, "enemy"),
  new Tower(200, 50, 5000, "enemy", true), // Enemy king tower
  new Tower(325, 100, 3000, "enemy")
];

class Unit {
  constructor(x, y, team, type = "Knight") {
    this.x = x;
    this.y = y;
    this.team = team;
    this.type = type;  // Knight, Archer, etc.

    // Default stats
    if (type === "Knight") {
      this.hp = 1800;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 24;
      this.attackRange = 20;
      this.attackDamage = 175;
      this.attackCooldown = 60;
      this.targetsOnlyBuildings = false;
    } else if (type === "Archer") {
      this.hp = 300;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 16;
      this.attackRange = 145;  // longer range
      this.attackDamage = 125;   // weaker per shot
      this.attackCooldown = 60;
      this.targetsOnlyBuildings = false;
    } else if (type === "Musketeer") {
      this.hp = 700;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 20;
      this.attackRange = 160;  // very long range
      this.attackDamage = 225;   // strong per shot
      this.attackCooldown = 60;
      this.targetsOnlyBuildings = false;
    } else if (type === "Giant") {
      this.hp = 4000;
      this.maxHp = this.hp;
      this.speed = 0.3;
      this.r = 36;
      this.attackRange = 20;  // melee range
      this.attackDamage = 175;
      this.attackCooldown = 90;  // slower attack speed
      this.targetsOnlyBuildings = true;  // Only targets towers!
    }

    this.sightRange = 150;
    this.target = null;
    this.currentAttackCooldown = 0;
  }

  update() {
    if (this.currentAttackCooldown > 0) this.currentAttackCooldown--;

    if (this.target && this.target.hp <= 0) this.target = null;

    if (!this.target) {
      let closest = null;
      let closestDist = Infinity;

      // If unit targets only buildings (like Giant), skip enemy units
      if (!this.targetsOnlyBuildings) {
        const enemyUnits = units.filter(u => u.team !== this.team);
        for (const u of enemyUnits) {
          const d = distance(this, u);
          if (d < closestDist && d <= this.sightRange) {
            closest = u;
            closestDist = d;
          }
        }
      }

      // Always check enemy towers
      const enemyTowersList = this.team === "player" ? enemyTowers : playerTowers;
      if (!closest || this.targetsOnlyBuildings) {
        for (const t of enemyTowersList) {
          const d = distance(this, t);
          if (d < closestDist) {
            closest = t;
            closestDist = d;
          }
        }
      }

      this.target = closest;
    }

    if (!this.target) return;

    const d = distance(this, this.target);

    if (d <= this.attackRange) {
      if (this.currentAttackCooldown === 0) {
        this.target.hp -= this.attackDamage;
        this.currentAttackCooldown = this.attackCooldown;
      }
      return; // stop moving while attacking
    }

    // Move logic
    let moveX, moveY;
    if (sameSide(this, this.target)) {
      moveX = this.target.x;
      moveY = this.target.y;
    } else {
      const bridge = this.closestBridge();
      moveX = bridge.x;
      moveY = bridge.y;
    }

    const dx = moveX - this.x;
    const dy = moveY - this.y;
    const mag = Math.hypot(dx, dy);
    if (mag > 0) {
      this.x += (dx / mag) * this.speed;
      this.y += (dy / mag) * this.speed;
    }
  }

  closestBridge() {
    let best = null;
    let minDist = Infinity;
    for (const b of bridges) {
      const d = Math.hypot(b.x - this.x, b.y - this.y);
      if (d < minDist) {
        minDist = d;
        best = b;
      }
    }
    return best;
  }

  closestTower(towers) {
    let best = null;
    let minDist = Infinity;
    for (const t of towers) {
      const d = Math.hypot(t.x - this.x, t.y - this.y);
      if (d < minDist) {
        minDist = d;
        best = t;
      }
    }
    return best;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);

    if (this.type === "Knight") ctx.fillStyle = "yellow";
    else if (this.type === "Archer") ctx.fillStyle = "magenta";
    else if (this.type === "Musketeer") ctx.fillStyle = "purple";
    else if (this.type === "Giant") ctx.fillStyle = "orange";

    ctx.fill();
    ctx.closePath();

    // HP bar
    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(
      this.x - this.r,
      this.y - this.r - 6,
      (this.hp / this.maxHp) * this.r * 2,
      4
    );
}
}

// Function to generate elixir
function generateElixir() {
  if (playerElixir < maxElixir) playerElixir += 1;
  if (enemyElixir < maxElixir) enemyElixir += 1;
  
  console.log("Player Elixir:", playerElixir, "Enemy Elixir:", enemyElixir);
}

// Draw loop
function drawArena() {
  // Draw grass
  ctx.fillStyle = "lightgreen";
  ctx.fillRect(0, 0, canvas.width, 600);

  // Draw hand 
  ctx.fillStyle = "#ddd";
  ctx.fillRect(0, 700, canvas.width, 150);
  drawHand();

  // Draw river
  ctx.fillStyle = "#1E90FF"; // blue river
  ctx.fillRect(0, 275, canvas.width, 50);

  // Draw bridges
  ctx.fillStyle = "#8B4513"; // brown
  const bridgeWidth = 50;
  const bridgeHeight = 100;
  const bridgeXs = [75, 325];

  for (let x of bridgeXs) {
    ctx.fillRect(x - bridgeWidth / 2, 275 - (bridgeHeight - 50) / 2, bridgeWidth, bridgeHeight);
  }

  // Update and draw towers
  updateTowers();

  // Update and draw units
  for (let i = units.length - 1; i >= 0; i--) {
    const u = units[i];
    u.update();
    u.draw(ctx);

    if (u.hp <= 0) {
      units.splice(i, 1);
    }
  }

  // Draw elixir bar
  drawElixirBar();

  requestAnimationFrame(drawArena);
}

drawArena();
  
// Generate 1 elixir every 2.8 seconds
setInterval(generateElixir, 2800);

// Event listener
canvas.addEventListener("click", function (e) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // 1ï¸âƒ£ Check card clicks FIRST
  for (let i = 0; i < handCards.length; i++) {
    const c = handCards[i];

    if (
      mouseX >= c.x &&
      mouseX <= c.x + c.w &&
      mouseY >= c.y &&
      mouseY <= c.y + c.h
    ) {
      selectedCardIndex = i;
      console.log("Selected card:", i);
      return; // stop here
    }
  }

  // 2ï¸âƒ£ Check arena click
  if (selectedCardIndex !== null && mouseY <= ARENA_HEIGHT) {
    const card = cards[selectedCardIndex];

    if (!canPlaceCard(card, mouseX, mouseY, "player")) {
      console.log("Illegal placement");
      return;
    }

    const cost = card.cost;
    
    if (playerElixir < cost) {
      console.log("Not enough elixir!");
      return;
    }

    playerElixir -= cost;

    // Spawn cards
    if (card.name === "Knight") {
      units.push(new Unit(mouseX, mouseY, "player", "Knight"));
    } else if (card.name === "Archers") {
      units.push(new Unit(mouseX - 25, mouseY, "player", "Archer"));
      units.push(new Unit(mouseX + 25, mouseY, "player", "Archer"));
    } else if (card.name === "Musketeer") {
      units.push(new Unit(mouseX, mouseY, "player", "Musketeer"));
    } else if (card.name === "Giant") {
      units.push(new Unit(mouseX, mouseY, "player", "Giant"));
    }

    console.log("Spawned", card.name, "at", mouseX, mouseY);

    selectedCardIndex = null;
  }
});

</script>

</body>
</html>
