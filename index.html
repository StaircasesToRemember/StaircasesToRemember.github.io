ow<!DOCTYPE html>
<html>
<body>

<canvas id="arena" width="400" height="1000" style="border:0px solid black;"></canvas>

<script>
const canvas = document.getElementById("arena");
const ctx = canvas.getContext("2d");
const cardCosts = [3, 4, 2, 5]; // cost for each of the 4 cards
const units = [];
const bridges = [
  { x: 75, y: 600 / 2 },  // middle of first bridge
  { x: 325, y: 600 / 2 }  // middle of second bridge
];


// Player elixir values
let playerElixir = 6;
let enemyElixir = 6;
const maxElixir = 10;

// Card selected variables
let selectedCardIndex = null; // 0â€“3, or null if none selected
const handCards = [];
const ARENA_HEIGHT = 600;

function spawnUnit(x, y, team) {
  units.push({
    x: x,
    y: y,
    r: 10,
    team: team,
    hp: 100
  });
}

function drawUnits() {
  for (const u of units) {
    u.draw(ctx);
  }
}

function getEnemyUnits(unit) {
  return units.filter(u => u.team !== unit.team);
}

  
// Draw elixir bar
function drawElixirBar() {
  const barWidth = 200;
  const barHeight = 20;
  const x = 100;
  const y = 650;

  // ðŸ”´ CLEAR the elixir bar area first
  ctx.clearRect(x - 5, y - 5, barWidth + 120, barHeight + 20);

  // Background
  ctx.fillStyle = "lightgray";
  ctx.fillRect(x, y, barWidth, barHeight);

  // Elixir fill
  ctx.fillStyle = "magenta";
  const fillWidth = (playerElixir / maxElixir) * barWidth;
  ctx.fillRect(x, y, fillWidth, barHeight);

  // Text
  ctx.fillStyle = "magenta";
  ctx.font = "16px Arial";
  ctx.fillText(
    playerElixir + " / " + maxElixir,
    x + barWidth + 10,
    y + barHeight - 4
  );
}

// Draw hand
function drawHand() {
  const cardWidth = 70;
  const cardHeight = 100;
  const startX = 25;
  const y = 725;
  const spacing = 24;

  for (let i = 0; i < 4; i++) {
    const x = startX + i * (cardWidth + spacing);

    // store card bounds
    handCards.push({ x, y, w: cardWidth, h: cardHeight });

    // highlight if selected
    if (selectedCardIndex === i) {
      ctx.fillStyle = "gold";
      ctx.fillRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8);
    }

    // card body
    const cost = cardCosts[i];

    if (playerElixir < cost) {
      ctx.globalAlpha = 0.5;
    }

    ctx.fillStyle = "white";
    ctx.fillRect(x, y, cardWidth, cardHeight);
    ctx.globalAlpha = 1.0;


    // border
    ctx.strokeStyle = "black";
    ctx.strokeRect(x, y, cardWidth, cardHeight);
  }
}
  
  
// Tower class
class Tower {
  constructor(x, y, hp, team) {
    this.x = x;
    this.y = y;
    this.hp = hp;
    this.maxHp = hp;
    this.team = team;
  }

  draw(ctx) {
    ctx.fillStyle = this.team === "player" ? "lightskyblue" : "lightpink";
    ctx.fillRect(this.x - 25, this.y - 25, 50, 50);
    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(this.x - 25, this.y - 35, 50 * (this.hp / this.maxHp), 5);
  }
}

// Create towers
const playerTowers = [
  new Tower(75, 500, 1000, "player"),
  new Tower(200, 550, 2000, "player"),
  new Tower(325, 500, 1000, "player")
];

const enemyTowers = [
  new Tower(75, 100, 1000, "enemy"),
  new Tower(200, 50, 2000, "enemy"),
  new Tower(325, 100, 1000, "enemy")
];

class Unit {
  constructor(x, y, team) {
    this.x = x;
    this.y = y;
    this.team = team;
    this.hp = 100;
    this.r = 12;
    this.type = "knight";

    this.speed = 1.0;
    this.sightRange = 150;
    this.target = null;
    this.attacking = false;
  }

  draw(ctx) {
    // Draw Knight
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 4);
    ctx.fillStyle = this.team === "player" ? "yellow" : "yellow";
    ctx.fill();
    ctx.closePath();

    // Draw HP bar
    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(this.x - this.r, this.y - this.r - 6, (this.hp / 100) * this.r * 2, 4);
    ctx.strokeStyle = "black";
    ctx.strokeRect(this.x - this.r, this.y - this.r - 6, this.r * 2, 4);
  }

update() {
  if (this.attacking) return; // donâ€™t move if attacking

  // Get all enemy units
  const enemyUnits = getEnemyUnits(this);

  // Determine which towers are â€œenemyâ€ for this unit
  const targetTowers = this.team === "player" ? enemyTowers : playerTowers;

  let closestTarget = null;
  let closestDist = Infinity;

  // 1ï¸âƒ£ Check for enemy units in sight range on the same side
  for (const e of enemyUnits) {
    const dx = e.x - this.x;
    const dy = e.y - this.y;
    const dist = Math.hypot(dx, dy);

    // same side: player > 300, enemy < 300
    const sameSide = (this.team === "player" && this.y >= 300) || 
                     (this.team === "opponent" && this.y <= 300);

    if (dist <= this.sightRange && sameSide && dist < closestDist) {
      closestDist = dist;
      closestTarget = e;
    }
  }

  // 2ï¸âƒ£ If no enemy unit found, check for enemy towers in sight
  if (!closestTarget) {
    for (const t of targetTowers) {
      const dx = t.x - this.x;
      const dy = t.y - this.y;
      const dist = Math.hypot(dx, dy);

      if (dist <= this.sightRange && dist < closestDist) {
        closestDist = dist;
        closestTarget = t;
      }
    }
  }

  // 3ï¸âƒ£ If still no target, decide where to move
  if (!closestTarget) {
    if ((this.team === "player" && sameSide) || (this.team === "opponent" && sameSide)) {
      // Own side â†’ move toward nearest bridge
      closestTarget = this.closestBridge();
    } else {
      // Enemy side â†’ move toward nearest enemy tower
      closestTarget = this.closestTower(targetTowers);
    }
  }

  // 4ï¸âƒ£ Move toward the target if it exists
  if (closestTarget) {
    const dx = closestTarget.x - this.x;
    const dy = closestTarget.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist > 1) {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
  }
}


  closestBridge() {
    let best = null;
    let minDist = Infinity;
    for (const b of bridges) {
      const dx = b.x - this.x;
      const dy = b.y - this.y;
      const d = Math.hypot(dx, dy);
      if (d < minDist) {
        minDist = d;
        best = b;
      }
    }
    return best;
  }

  closestTower(towers) {
    let best = null;
    let minDist = Infinity;
    for (const t of towers) {
      const dx = t.x - this.x;
      const dy = t.y - this.y;
      const d = Math.hypot(dx, dy);
      if (d < minDist) {
        minDist = d;
        best = t;
      }
    }
    return best;
  }
}



// Function to generate elixir
function generateElixir() {
  if (playerElixir < maxElixir) playerElixir += 1;
  if (enemyElixir < maxElixir) enemyElixir += 1;
  
  console.log("Player Elixir:", playerElixir, "Enemy Elixir:", enemyElixir);
}

// Draw loop
  // Draw grass
function drawArena() {
  ctx.fillStyle = "lightgreen";
  ctx.fillRect(0, 0, canvas.width, 600);

  // Draw hand 
  ctx.fillStyle = "#ddd";
  ctx.fillRect(0, 700, canvas.width, 150);
  drawHand();
  
   // Draw river
  ctx.fillStyle = "#1E90FF"; // blue river
  ctx.fillRect(0, 275, canvas.width, 50);

    // Draw bridges
  ctx.fillStyle = "#8B4513"; // brown
  const bridgeWidth = 50;
  const bridgeHeight = 100;
  const bridgeXs = [75, 325];

  for (let x of bridgeXs) {
    ctx.fillRect(x - bridgeWidth/2, 275 - (bridgeHeight - 50)/2, bridgeWidth, bridgeHeight);
  }

  for (let t of playerTowers) {
    t.draw(ctx);
  }

  for (let t of enemyTowers) {
    t.draw(ctx);
  }

  //draw units
  for (const u of units) {
    u.update();
    u.draw(ctx);
  }


  //draw elixir bar
  drawElixirBar();

  requestAnimationFrame(drawArena);
}

drawArena();
  
// Generate 1 elixir every 2.8 seconds
setInterval(generateElixir, 2800);

  // Event listener
 canvas.addEventListener("click", function (e) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // 1ï¸âƒ£ Check card clicks FIRST
  for (let i = 0; i < handCards.length; i++) {
    const c = handCards[i];

    if (
      mouseX >= c.x &&
      mouseX <= c.x + c.w &&
      mouseY >= c.y &&
      mouseY <= c.y + c.h
    ) {
      selectedCardIndex = i;
      console.log("Selected card:", i);
      return; // stop here
    }
  }

// 2ï¸âƒ£ Check arena click
if (selectedCardIndex !== null && mouseY <= ARENA_HEIGHT) {
  const cost = cardCosts[selectedCardIndex];

  if (playerElixir < cost) {
    console.log("Not enough elixir!");
    return;
  }

  playerElixir -= cost;

  // SPAWN KNIGHT
  units.push(new Unit(mouseX, mouseY, "player"));

  console.log("Spawned Knight at", mouseX, mouseY);

  selectedCardIndex = null;
}

});

</script>

</body>
</html>
