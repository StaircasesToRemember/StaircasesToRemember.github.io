<!DOCTYPE html>
<html>
<body>

<canvas id="arena" width="400" height="1000" style="border:0px solid black;"></canvas>

<script>
let timeLeft = 180; // 3 minutes in seconds
let normalInterval = 2800; // 1 elixir every 2.8s
let doubleElixir = false;
let elixirIntervalId;const canvas = document.getElementById("arena");
const ctx = canvas.getContext("2d");
const units = [];
const bridges = [
  { x: 75, y: 600 / 2 },  // middle of first bridge
  { x: 325, y: 600 / 2 }  // middle of second bridge
];
const RIVER_TOP = 275;
const RIVER_BOTTOM = 325;
const PlacementType = {
  PLAYER_SIDE_ONLY: "player",
  ANYWHERE: "anywhere"
};

// Player elixir values
let playerElixir = 6;
let enemyElixir = 6;
const maxElixir = 10;
const effects = [];
const cards = [
  { id: "knight", name: "Knight", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY },
  { id: "archers", name: "Archers", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY },
  { id: "musketeer", name: "Musketeer", cost: 4, placement: PlacementType.PLAYER_SIDE_ONLY },
  { id: "giant", name: "Giant", cost: 5, placement: PlacementType.PLAYER_SIDE_ONLY },
  { id: "minions", name: "Minions", cost: 3, placement: PlacementType.PLAYER_SIDE_ONLY },
  { id: "mini_pekka", name: "Mini Pekka", cost: 4, placement: PlacementType.PLAYER_SIDE_ONLY },
  { id: "fireball", name: "Fireball", cost: 4, placement: PlacementType.ANYWHERE, type: "spell", radius: 60, damage: 650 },
  { id: "arrows", name: "Arrows", cost: 3, placement: PlacementType.ANYWHERE, type: "spell", radius: 75, damage: 325 },
  { id: "skeletons", name: "Skeletons", cost: 1, placement: PlacementType.PLAYER_SIDE_ONLY }
];
  
playerDeck = [0, 8, 2, 3, 4, 5, 6, 7]; // indices into cards
enemyDeck = [8, 8, 8, 8, 8, 8, 8, 8]; // indices into cards
  
// Create a fresh shuffled deck for the player
function initializeDeck(deckArray) {
  const shuffled = [...deckArray].sort(() => Math.random() - 0.5);
  const hand = shuffled.slice(0, 4);       // first 4 go to hand
  const deck = shuffled.slice(4);          // rest stay in deck
  return { hand, deck };
}

let playerState = initializeDeck(playerDeck);
let enemyState = initializeDeck(enemyDeck);

let playerHand = playerState.hand;
playerDeck = playerState.deck;

let enemyHand = enemyState.hand;
enemyDeck = enemyState.deck;

console.log("Player deck:", playerDeck);
console.log("Player hand:", playerHand);
console.log("Enemy deck:", enemyDeck);
console.log("Enemy hand:", enemyHand);

function cycleCard(handArray, deckArray, handIndex) {
  const playedCard = handArray.splice(handIndex, 1)[0]; // remove from hand

  // draw the next card from the deck
  const nextCard = deckArray.shift();
  handArray.push(nextCard);

  // put the played card at the bottom of the deck
  deckArray.push(playedCard);
}

const cardAI = {
  knight: {
    reactiveOffset: { x: 25, y: -25 }, // spawn below enemy troop
    investPos1: { x: 199, y: 0 },
    investPos2: { x: 201, y: 0 }
  },
  archers: {
    reactiveOffset: { x: 25, y: -145 },
    investPos1: { x: 199, y: 0 },
    investPos2: { x: 201, y: 0 }
  },
  musketeer: {
    reactiveOffset: { x: 25, y: -160 },
    investPos1: { x: 199, y: 0 },
    investPos2: { x: 201, y: 0 }
  },
  giant: {
    reactiveOffset: { x: 25, y: -160 },
    investPos1: { x: 199, y: 0 },
    investPos2: { x: 201, y: 0 }
  },
  mini_pekka: {
    reactiveOffset: { x: 25, y: -25 },
    investPos1: { x: 199, y: 0 },
    investPos2: { x: 201, y: 0 }
  },
  minions: {
    reactiveOffset: { x: 25, y: -75 },
    investPos1: { x: 50, y: 0 },
    investPos2: { x: 350, y: 0 }
  },
  fireball: {
    reactiveOffset: { x: 0, y: 0 },
  },
  arrows: {
    reactiveOffset: { x: 0, y: 0 },
  },
  skkeletons: {
    reactiveOffset: { x: 25, y: 0 },
    investPos1: { x: 199, y: 0 },
    investPos2: { x: 201, y: 0 }
  }
};

const SPELL_UNIT_VALUES = {
  Fireball: {
    Knight: 1,
    Archer: 1.5,
    Musketeer: 2,
    Giant: 0.5,
    Minion: 1,
    "Mini Pekka": 1,
    Skeleton: 0.3,

    tower: 2,
    kingTower: -5
  },

  Arrows: {
    Knight: 0.5,
    Archer: 1.5,
    Musketeer: 1,
    Giant: 0.25,
    Minion: 1,
    "Mini Pekka": 0.5,
    Skeleton: 0.3,

    tower: 1,
    kingTower: -5
  }
};
  
// Card selected variables
let selectedCardIndex = null; // 0‚Äì3, or null if none selected
const handCards = [];
const ARENA_HEIGHT = 600;

const ATTACK_RANGE = 20;
const ATTACK_DAMAGE = 170;
const ATTACK_COOLDOWN = 60; // frames (~1 second at 60fps)

function sameSide(a, b) {
  // both above river
  if (a.y < RIVER_BOTTOM && b.y < RIVER_BOTTOM) return true;
  // both below river
  if (a.y > RIVER_TOP && b.y > RIVER_TOP) return true;
  return false;
}

function sideHasPocket(team, side) {
  const towers = team === "player" ? enemyTowers : playerTowers;
  const midX = canvas.width / 2;

  return !towers.some(t =>
    !t.isKing &&
    (side === "left" ? t.x < midX : t.x > midX)
  );
}

function isInPocket(x, y, team) {
  const midX = canvas.width / 2;
  const pocketDepth = 75;

  // Which side of arena?
  const side = x < midX ? "left" : "right";

  if (!sideHasPocket(team, side)) return false;

  // Pocket Y range depends on team
  if (team === "player") {
    return y < RIVER_TOP && y >= RIVER_TOP - pocketDepth;
  } else {
    return y > RIVER_BOTTOM && y <= RIVER_BOTTOM + pocketDepth;
  }
}

function canPlaceCard(card, x, y, team) {
  // River is always blocked
  if (y >= RIVER_TOP && y <= RIVER_BOTTOM) return false;

  if (card.placement === PlacementType.PLAYER_SIDE_ONLY) {

    // Normal side restriction
    if (team === "player" && y < RIVER_BOTTOM) {
      if (!isInPocket(x, y, team)) return false;
    }

    if (team === "enemy" && y > RIVER_TOP) {
      if (!isInPocket(x, y, team)) return false;
    }
  }

  return true;
}

function furthestEnemyOnOurSide(team) {
  const candidates = units.filter(u => {
    if (u.team === team) return false;
    return team === "enemy" ? u.y < RIVER_TOP - 5 : u.y > RIVER_BOTTOM + 5;
  });

  if (candidates.length === 0) return null;

  return candidates.reduce((a, b) =>
    distanceToEnemySide(a, team) > distanceToEnemySide(b, team) ? a : b
  );
}

function distanceToEnemySide(unit, team) {
  return team === "enemy" ? unit.y : canvas.height - unit.y;
}

function spellUnitValue(card, target) {
  const table = SPELL_UNIT_VALUES[card.name];
  if (!table) return 0;

  if (target instanceof Tower) {
    return target.isKing
      ? table.kingTower ?? 0
      : table.tower ?? 0;
  }

  return table[target.type] ?? 0;
}

function bestSpellTarget(card, team) {
  let bestTarget = null;
  let bestValue = 0;

  const enemies = [
    ...units.filter(u => u.team !== team),
    ...(team === "player" ? enemyTowers : playerTowers)
  ];

  for (const candidate of enemies) {
    let value = 0;

    for (const e of enemies) {
      if (distance(candidate, e) <= card.radius) {
        value += spellUnitValue(card, e);
      }
    }

    if (value > bestValue) {
      bestValue = value;
      bestTarget = candidate;
    }
  }

  return bestValue > card.cost ? bestTarget : null;
}

function resolveEnemyPlacement(card, team) {
  const ai = cardAI[card.id];

  const threat = card.type === "spell"
    ? bestSpellTarget(card, team)
    : furthestEnemyOnOurSide(team);

  if (threat && ai?.reactiveOffset && enemyElixir >= playerElixir) {
    return {
      x: threat.x + ai.reactiveOffset.x,
      y: Math.max(threat.y + ai.reactiveOffset.y, 0)
    };
  }

  if (!threat && ai.investPos1 && enemyElixir >= 9) {
    return Math.random() > 0.5 ? ai.investPos1 : ai.investPos2;
  }

  return null;
}
 
function enemyPlayCard() {
  // 1Ô∏è‚É£ Randomly select a playable card
  const playable = enemyHand
    .map(i => cards[i])
    .filter(c => enemyElixir >= c.cost);

  if (playable.length === 0) return;

  const card = playable[Math.floor(Math.random() * playable.length)];
  const cardIndex = cards.indexOf(card);
  const handIndex = enemyHand.indexOf(cardIndex);

  // 2Ô∏è‚É£ Determine placement
  const pos = resolveEnemyPlacement(card, "enemy");

  // 3Ô∏è‚É£ Do nothing if no valid placement
  if (!pos) return;

  enemyElixir -= card.cost;

  if (card.type === "spell") {
    castSpell(card, pos.x, pos.y, "enemy");
  } else {
    if (canPlaceCard(card, pos.x, pos.y, "enemy")) {
      spawnEnemyUnit(card, pos.x, pos.y);
    }
  }

  cycleCard(enemyHand, enemyDeck, handIndex);
}



function spawnEnemyUnit(card, x, y) {
  if (card.name === "Knight") {
    units.push(new Unit(x, y, "enemy", "Knight"));
  } 
  else if (card.name === "Archers") {
    units.push(new Unit(x - 15, y, "enemy", "Archer"));
    units.push(new Unit(x + 15, y, "enemy", "Archer"));
  } 
  else if (card.name === "Musketeer") {
    units.push(new Unit(x, y, "enemy", "Musketeer"));
  } 
  else if (card.name === "Giant") {
    units.push(new Unit(x, y, "enemy", "Giant"));
  }
  else if (card.name === "Minions") {
    units.push(new Unit(x - 15, y - 25, "enemy", "Minion"));
    units.push(new Unit(x + 15, y - 25, "enemy", "Minion"));
    units.push(new Unit(x, y, "enemy", "Minion"));
  }
  else if (card.name === "Mini Pekka") {
    units.push(new Unit(x, y, "enemy", "Mini Pekka"));
  } 
    else if (card.name === "Skeletons") {
    units.push(new Unit(x - 15, y - 25, "enemy", "Skeleton"));
    units.push(new Unit(x + 15, y - 25, "enemy", "Skeleton"));
    units.push(new Unit(x, y, "enemy", "Skeleton"));
  }
}

function castSpell(card, x, y, team) {
    if (card.name === "Fireball" || card.name === "Arrows") {
        for (const u of units) {
            if (u.team === team) continue;
            const d = distance({ x, y }, u);
            if (d <= card.radius) u.hp -= card.damage;
        }

        // damage towers too
        const targetTowers = team === "player" ? enemyTowers : playerTowers;
        for (const t of targetTowers) {
            const d = distance({ x, y }, t);
            if (d <= card.radius) t.hp -= card.damage;
        }

        if (card.name === "Fireball") {
            effects.push({ x, y, radius: card.radius, timer: 30, type: "fireball" });
        } else if (card.name === "Arrows") {
            // Generate arrow dots once
            const dotCount = 50;
            const dots = [];
            for (let j = 0; j < dotCount; j++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * card.radius;
                dots.push({ 
                    x: x + r * Math.cos(angle), 
                    y: y + r * Math.sin(angle) 
                });
            }
            effects.push({ x, y, radius: card.radius, timer: 50, type: "arrows", dots });
        }
    }
}
      
function drawEffects() {
    for (let i = effects.length - 1; i >= 0; i--) {
        const e = effects[i];

        if (e.type === "fireball") {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,100,0,${e.timer / 30})`;
            ctx.fill();
            ctx.closePath();
        } 
        else if (e.type === "arrows") {
            for (const dot of e.dots) {
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = "maroon";
                ctx.fill();
                ctx.closePath();
            }
        }

        e.timer--;
        if (e.timer <= 0) effects.splice(i, 1);
    }
}

function drawTimer() {
  const minutes = Math.floor(timeLeft / 60);
  const seconds = timeLeft % 60;
  ctx.fillStyle = "red";
  ctx.font = "24px Arial";
  ctx.textAlign = "right";
  ctx.fillText(`${minutes}:${seconds.toString().padStart(2,'0')}`, canvas.width, 30);

  if (doubleElixir) {
    ctx.font = "20px Arial";
    ctx.fillText("x2", canvas.width, 60);
  }
  if (timeLeft <= 0) {
    ctx.font = "20px Arial";
    ctx.fillText("SD", canvas.width, 90);
  }
}

function drawUnits() {
  for (const u of units) {
    u.draw(ctx);
  }
}

function getEnemyUnits(unit) {
  return units.filter(u => u.team !== unit.team);
}

function drawPockets() {
  ctx.strokeStyle = "magenta";
  ctx.lineWidth = 1;

  const midX = canvas.width / 2;
  const pocketDepth = 75;

  // PLAYER pockets (enemy tower destroyed)
  if (sideHasPocket("player", "left")) {
    ctx.strokeRect(
      0,
      RIVER_TOP - pocketDepth,
      midX,
      pocketDepth
    );
  }

  if (sideHasPocket("player", "right")) {
    ctx.strokeRect(
      midX,
      RIVER_TOP - pocketDepth,
      midX,
      pocketDepth
    );
  }

  // ENEMY pockets (player tower destroyed)
  if (sideHasPocket("enemy", "left")) {
    ctx.strokeRect(
      0,
      RIVER_BOTTOM,
      midX,
      pocketDepth
    );
  }

  if (sideHasPocket("enemy", "right")) {
    ctx.strokeRect(
      midX,
      RIVER_BOTTOM,
      midX,
      pocketDepth
    );
  }
}

  
// Draw elixir bar
function drawElixirBar() {
  const barWidth = 200;
  const barHeight = 20;
  const x = 100;
  const y = 650;

  // üî¥ CLEAR the elixir bar area first
  ctx.clearRect(x - 5, y - 5, barWidth + 120, barHeight + 20);

  // Background
  ctx.fillStyle = "lightgray";
  ctx.fillRect(x, y, barWidth, barHeight);

  // Elixir fill
  ctx.fillStyle = "magenta";
  const fillWidth = (playerElixir / maxElixir) * barWidth;
  ctx.fillRect(x, y, fillWidth, barHeight);

  // Text
  ctx.fillStyle = "magenta";
  ctx.font = "16px Arial";
  ctx.fillText(
    playerElixir + " / " + maxElixir,
    x + barWidth + 20,
    y + barHeight - 4
  );
}

function distance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}
  
// Draw hand
function drawHand() {
  handCards.length = 0;
  const cardWidth = 70;
  const cardHeight = 100;
  const startX = 25;
  const y = 725;
  const spacing = 24;

  for (let i = 0; i < 4; i++) {
    const x = startX + i * (cardWidth + spacing);
    const cardIndex = playerHand[i];
    const card = cards[cardIndex];
    const cost = card.cost;

    // store card bounds
    handCards.push({ x, y, w: cardWidth, h: cardHeight });

    // highlight if selected
    if (selectedCardIndex === i) {
      ctx.fillStyle = "gold";
      ctx.fillRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8);
    }

    // Dim card if not enough elixir
    if (playerElixir < cost) {
      ctx.globalAlpha = 0.5;
    }

    // card body
    ctx.fillStyle = "white";
    ctx.fillRect(x, y, cardWidth, cardHeight);

    // Draw unit icon/circle in the middle
    ctx.globalAlpha = 1.0;
    ctx.beginPath();
    ctx.arc(x + cardWidth / 2, y + 35, 20, 0, Math.PI * 2);
    
    if (card.name === "Knight") ctx.fillStyle = "yellow";
    if (card.name === "Archers") ctx.fillStyle = "magenta";
    if (card.name === "Musketeer") ctx.fillStyle = "blueviolet";
    if (card.name === "Giant") ctx.fillStyle = "orange";
    if (card.name === "Minions") ctx.fillStyle = "cornflowerblue";
    if (card.name === "Mini Pekka") ctx.fillStyle = "navy";
    if (card.name === "Fireball") ctx.fillStyle = "red";
    if (card.name === "Arrows") ctx.fillStyle = "maroon";
    if (card.name === "Skeletons") ctx.fillStyle = "floralwhite";

    ctx.fill();
    ctx.closePath();

    // Draw unit name
    ctx.fillStyle = "black";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.fillText(card.name, x + cardWidth / 2, y + 70);

    // Draw elixir cost in magenta at bottom
    ctx.fillStyle = "magenta";
    ctx.font = "bold 16px Arial";
    ctx.fillText(cost, x + cardWidth / 2, y + 90);

    ctx.globalAlpha = 1.0;

    // border
    ctx.strokeStyle = "black";
    ctx.strokeRect(x, y, cardWidth, cardHeight);
  }
}

// In drawArena or a separate tower management function:
function updateTowers() {
  // Player towers
  for (let i = playerTowers.length - 1; i >= 0; i--) {
    const t = playerTowers[i];
    t.update();
    t.draw(ctx);

    // Optional: draw attack line
    if (t.target) {
      ctx.strokeStyle = t.team === "player" ? "blue" : "red";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(t.x, t.y);
      ctx.lineTo(t.target.x, t.target.y);
      ctx.stroke();
    }

    if (!t.isKing && t.hp <= 0) {
      // Remove the dead tower
      playerTowers.splice(i, 1);
    
      // Apply 1 damage to all remaining towers
      for (let j = 0; j < playerTowers.length; j++) {
        playerTowers[j].hp--;
      }
    }

    if (t.isKing && t.hp <= 0) {
      alert("You lose!");
      location.reload(); // simple game over reset
    }
  }

  // Enemy towers
  for (let i = enemyTowers.length - 1; i >= 0; i--) {
    const t = enemyTowers[i];
    t.update();
    t.draw(ctx);

    if (t.target) {
      ctx.strokeStyle = t.team === "player" ? "blue" : "red";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(t.x, t.y);
      ctx.lineTo(t.target.x, t.target.y);
      ctx.stroke();
    }

    if (!t.isKing && t.hp <= 0) {
      enemyTowers.splice(i, 1);
       for (let j = 0; j < enemyTowers.length; j++) {
        enemyTowers[j].hp--;
      }
    }
    if (t.isKing && t.hp <= 0) {
      alert("You win!");
      location.reload(); // simple game over reset
      
    }
  }
}

  
// Tower class
class Tower {
  constructor(x, y, hp, team, isKing = false) {
    this.x = x;
    this.y = y;
    this.hp = hp;
    this.maxHp = hp;
    this.team = team;
    this.isKing = isKing;

    this.range = 175;
    this.damage = 140;
    this.attackCooldown = 60;
    this.cooldown = 0;

    this.target = null; // üëà sticky target
  }

  draw(ctx) {
  // Determine tower color
  let fillColor;
  if (this.isKing && this.hp === this.maxHp) {
    fillColor = this.team === "player" ? "black" : "black"; // full-health king towers
  } else {
    fillColor = this.team === "player" ? "lightskyblue" : "lightpink"; // normal towers
  }

  ctx.fillStyle = fillColor;
  ctx.fillRect(this.x - 25, this.y - 25, 50, 50);

  // Draw HP bar
  ctx.fillStyle = this.team === "player" ? "blue" : "red";
  ctx.fillRect(this.x - 25, this.y - 35, 50 * (this.hp / this.maxHp), 5);
}

update() {
  if (this.hp <= 0) return;

  // King tower rule (only attacks after damaged)
  if (this.isKing && this.hp === this.maxHp) return;

  // If we have a target, check if it's still valid
  if (this.target) {
    const d = distance(this, this.target);

    if (this.target.hp <= 0 || d > this.range) {
      this.target = null; // ‚ùå drop target
    }
  }

  // Acquire target ONLY if none
  if (!this.target) {
    const enemies = units.filter(u =>
      u.team !== this.team &&
      distance(this, u) <= this.range
    );

    if (enemies.length > 0) {
      this.target = enemies[0]; // or closest if you want
    }
  }

  // Attack if possible
  if (this.target) {
    this.cooldown--;

    if (this.cooldown <= 0) {
      this.target.hp -= this.damage;
      this.cooldown = this.attackCooldown;
    }
  }
}
}

function startElixirInterval() {
  const interval = doubleElixir ? normalInterval / 2 : normalInterval;
  clearInterval(elixirIntervalId); // clear previous interval
  elixirIntervalId = setInterval(generateElixir, interval);
}
  
function endGameByTowers() {
  const playerTowerCount = playerTowers.length;
  const enemyTowerCount = enemyTowers.length;

  let message;
  if (playerTowerCount > enemyTowerCount) message = "You win!";
  else if (enemyTowerCount > playerTowerCount) message = "You lose!";
  else return;

  alert(message);
  location.reload(); // simple reset
}

  
// Create towers
const playerTowers = [
  new Tower(75, 500, 3000, "player"),
  new Tower(200, 550, 5000, "player", true), // King tower in center
  new Tower(325, 500, 3000, "player")
];

const enemyTowers = [
  new Tower(75, 100, 3000, "enemy"),
  new Tower(200, 50, 5000, "enemy", true), // Enemy king tower
  new Tower(325, 100, 3000, "enemy")
];

class Unit {
  constructor(x, y, team, type = "Knight") {
    this.x = x;
    this.y = y;
    this.team = team;
    this.type = type;  // Knight, Archer, etc.

    // Default stats
    if (type === "Knight") {
      this.hp = 1800;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 24;
      this.attackRange = 25;
      this.attackDamage = 175;
      this.attackCooldown = 60;
      this.isAir = false;
      this.attacksAir = false;
      this.targetsOnlyBuildings = false;
      this.sightRange = 170;
    } else if (type === "Archer") {
      this.hp = 300;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 16;
      this.attackRange = 145;  // longer range
      this.attackDamage = 125;   // weaker per shot
      this.attackCooldown = 60;
      this.isAir = false;
      this.attacksAir = true;
      this.targetsOnlyBuildings = false;
      this.sightRange = 170;
    } else if (type === "Musketeer") {
      this.hp = 700;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 20;
      this.attackRange = 160;  // very long range
      this.attackDamage = 225;   // strong per shot
      this.attackCooldown = 60;
      this.isAir = false;
      this.attacksAir = true;
      this.targetsOnlyBuildings = false;
      this.sightRange = 185;
    } else if (type === "Giant") {
      this.hp = 4000;
      this.maxHp = this.hp;
      this.speed = 0.35;
      this.r = 36;
      this.attackRange = 25;  // melee range
      this.attackDamage = 175;
      this.attackCooldown = 90;  // slower attack speed
      this.isAir = false;
      this.attacksAir = false;
      this.targetsOnlyBuildings = true;  // Only targets towers!
      this.sightRange = 200;
    } else if (type === "Minion") {
      this.hp = 240;
      this.maxHp = this.hp;
      this.speed = 0.6;
      this.r = 16;
      this.attackRange = 75;  // melee range
      this.attackDamage = 100;
      this.attackCooldown = 60;  // slower attack speed
      this.isAir = true;
      this.attacksAir = true;
      this.targetsOnlyBuildings = false;  // Only targets towers!
      this.sightRange = 170;
    } else if (type === "Mini Pekka") {
      this.hp = 1400;
      this.maxHp = this.hp;
      this.speed = 0.6;
      this.r = 20;
      this.attackRange = 25;
      this.attackDamage = 800;
      this.attackCooldown = 100;
      this.isAir = false;
      this.attacksAir = false;
      this.targetsOnlyBuildings = false;
      this.sightRange = 170;
    } else if (type === "Skeleton") {
      this.hp = 90;
      this.maxHp = this.hp;
      this.speed = 0.5;
      this.r = 8;
      this.attackRange = 25;
      this.attackDamage = 90;
      this.attackCooldown = 60;
      this.isAir = false;
      this.attacksAir = false;
      this.targetsOnlyBuildings = false;
      this.sightRange = 170;
    }
    
    this.target = null;
    this.currentAttackCooldown = 10;
  }

update() {

  // Drop target if dead
  if (this.target && this.target.hp <= 0) {
    this.target = null;
  }

  // üîí Sticky attacking:
  // If currently attacking, DO NOT retarget
  if (this.target) {
    const d = distance(this, this.target);

    if (d <= this.attackRange) {
      // Cooldown tick
      if (this.currentAttackCooldown > 0) {
        this.currentAttackCooldown--;
      }
      // Attack
      if (this.currentAttackCooldown === 0) {
        this.target.hp -= this.attackDamage;
        this.currentAttackCooldown = this.attackCooldown;
      }
      return; // stay locked while attacking
    }
  }

  this.currentAttackCooldown = this.attackCooldown;
  
  // üß† Only NOW do we search for a new target
  let closest = null;
  let closestDist = Infinity;

  // Enemy units
  if (!this.targetsOnlyBuildings) {
    for (const u of units) {
      if (u.team === this.team) continue;
      if (u.isAir && !this.attacksAir) continue;

      const d = distance(this, u);
      if (d < closestDist && d <= this.sightRange) {
        closest = u;
        closestDist = d;
      }
    }
  }

  // Enemy towers
  const enemyTowersList = this.team === "player" ? enemyTowers : playerTowers;
  for (const t of enemyTowersList) {
    const d = distance(this, t);
    if (d < closestDist) {
      closest = t;
      closestDist = d;
    }
  }

  this.target = closest;
  if (!this.target) return;

  // Move toward target
  let moveX, moveY;
  if (!this.isAir && !sameSide(this, this.target)) {
    const bridge = this.closestBridge();
    moveX = bridge.x;
    moveY = bridge.y;
  } else {
    moveX = this.target.x;
    moveY = this.target.y;
  }

  const dx = moveX - this.x;
  const dy = moveY - this.y;
  const mag = Math.hypot(dx, dy);
  if (mag > 0) {
    this.x += (dx / mag) * this.speed;
    this.y += (dy / mag) * this.speed;
  }
}

  closestBridge() {
    let best = null;
    let minDist = Infinity;
    for (const b of bridges) {
      const d = Math.hypot(b.x - this.x, b.y - this.y);
      if (d < minDist) {
        minDist = d;
        best = b;
      }
    }
    return best;
  }

  closestTower(towers) {
    let best = null;
    let minDist = Infinity;
    for (const t of towers) {
      const d = Math.hypot(t.x - this.x, t.y - this.y);
      if (d < minDist) {
        minDist = d;
        best = t;
      }
    }
    return best;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);

    if (this.type === "Knight") ctx.fillStyle = "yellow";
    else if (this.type === "Archer") ctx.fillStyle = "magenta";
    else if (this.type === "Musketeer") ctx.fillStyle = "blueviolet";
    else if (this.type === "Giant") ctx.fillStyle = "orange";
    else if (this.type === "Minion") ctx.fillStyle = "cornflowerblue";
    else if (this.type === "Mini Pekka") ctx.fillStyle = "navy";
    else if (this.type === "Skeleton") ctx.fillStyle = "floralwhite";

    ctx.fill();
    ctx.closePath();

    // HP bar
    ctx.fillStyle = this.team === "player" ? "blue" : "red";
    ctx.fillRect(
      this.x - this.r,
      this.y - this.r - 6,
      (this.hp / this.maxHp) * this.r * 2,
      4
    );
}
}
  
// Function to generate elixir
function generateElixir() {
  if (playerElixir < maxElixir) playerElixir += 1;
  if (enemyElixir < maxElixir) enemyElixir += 1;
}

// Draw loop
function drawArena() {
  // Draw grass
  ctx.fillStyle = "lightgreen";
  ctx.fillRect(0, 0, canvas.width, 600);

  // Draw river
  ctx.fillStyle = "#1E90FF"; // blue river
  ctx.fillRect(0, 275, canvas.width, 50);

  // Draw bridges
  ctx.fillStyle = "#8B4513"; // brown
  const bridgeWidth = 50;
  const bridgeHeight = 100;
  const bridgeXs = [75, 325];

  for (let x of bridgeXs) {
    ctx.fillRect(x - bridgeWidth / 2, 275 - (bridgeHeight - 50) / 2, bridgeWidth, bridgeHeight);
  }

  // Draw pockets
   drawPockets();

  // Update and draw towers
  updateTowers();

  // Update and draw units
  for (let i = units.length - 1; i >= 0; i--) {
    const u = units[i];
    u.update();
    u.draw(ctx);

    if (u.hp <= 0) {
      units.splice(i, 1);
    }
  }
  
  // Draw effects
  drawEffects()
  
  // Clear margin
  ctx.fillStyle = "white";
  ctx.fillRect(0, 600, canvas.width, 650);

  // Draw timer
  drawTimer();
  
  // Draw elixir bar
  drawElixirBar();
  console.log("Enemy elixir: ", enemyElixir);

  // Draw hand 
  ctx.fillStyle = "#ddd";
  ctx.fillRect(0, 700, canvas.width, 150);
  drawHand();
  
  requestAnimationFrame(drawArena);
}

drawArena();
  
// Generate elixir
startElixirInterval();  
setInterval(() => {
  if (timeLeft > 0) {
    timeLeft--;

    if (timeLeft === 59) {
      doubleElixir = true;
      startElixirInterval(); // restart interval at half the time
    }

  } else {
    endGameByTowers();
  }
}, 1000);


// Enemy AI makes decisions
setInterval(enemyPlayCard, 1000);
  
// Event listener
canvas.addEventListener("click", function (e) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // 1Ô∏è‚É£ Check card clicks FIRST
  for (let i = 0; i < handCards.length; i++) {
    const c = handCards[i];

    if (
      mouseX >= c.x &&
      mouseX <= c.x + c.w &&
      mouseY >= c.y &&
      mouseY <= c.y + c.h
    ) {
      selectedCardIndex = i;
      return; // stop here
    }
  }

  // 2Ô∏è‚É£ Check arena click
  if (selectedCardIndex !== null && mouseY <= ARENA_HEIGHT) {
    const cardId = playerHand[selectedCardIndex];
    const card = cards[cardId];
        
    if (!canPlaceCard(card, mouseX, mouseY, "player")) {
      return;
    }

    const cost = card.cost;
    
    if (playerElixir < cost) {
      return;
    }

    playerElixir -= cost;

      if (card.type === "spell") {
      castSpell(card, mouseX, mouseY, "player");
    } else if (card.name === "Knight") {
      units.push(new Unit(mouseX, mouseY, "player", "Knight"));
    } else if (card.name === "Archers") {
      units.push(new Unit(mouseX - 15, mouseY, "player", "Archer"));
      units.push(new Unit(mouseX + 15, mouseY, "player", "Archer"));
    } else if (card.name === "Musketeer") {
      units.push(new Unit(mouseX, mouseY, "player", "Musketeer"));
    } else if (card.name === "Giant") {
      units.push(new Unit(mouseX, mouseY, "player", "Giant"));
    } else if (card.name === "Minions") {
      units.push(new Unit(mouseX - 15, mouseY + 25, "player", "Minion"));
      units.push(new Unit(mouseX + 15, mouseY + 25, "player", "Minion"));
      units.push(new Unit(mouseX, mouseY, "player", "Minion"));
    } else if (card.name === "Mini Pekka") {
      units.push(new Unit(mouseX, mouseY, "player", "Mini Pekka"));
    } else if (card.name === "Skeletons") {
      units.push(new Unit(mouseX - 15, mouseY + 25, "player", "Skeleton"));
      units.push(new Unit(mouseX + 15, mouseY + 25, "player", "Skeleton"));
      units.push(new Unit(mouseX, mouseY, "player", "Skeleton"));
    }

    cycleCard(playerHand, playerDeck, selectedCardIndex);
    selectedCardIndex = null;
  }
});

</script>

</body>
</html>
